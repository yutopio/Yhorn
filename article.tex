\documentclass{llncs}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{syntax}

\title{Solving Horn clauses over LI}
\author{Yuto Takei}
\institute{The University of Tokyo}

\begin{document}
\maketitle
\begin{abstract}
  This is the abstract.
\end{abstract}

\section{Introduction}


* Formal verification
--> Dependent typing of SHP
--> Horn clauses

* Some
Background for Horn clause solving
* Dependent type determination

Horn clause solving is a problem of constraint solving that is consisted of multiple Horn clauses with unknown predicate symbols. The solution is an assignment for such symbols so that all given Horn clauses stay valid. There may be multiple solutions for one problem, and the algorithm is expected to show at least one.

In this paper, we present a novel algorithm to solve Horn clauses. As the unique feature of the algorithm, we preserve the solution space throughout the computation. We are able to provide multiple assignments for predicate symbols. Additionally, this technique enables us to handle general Horn clauses rather than the recursion-free ones, which was the major restriction of the previous work.

The rest of our paper is structured as follows: Section 2 shows the basic algorithm to solve recursion-free Horn clauses with solution space consideration. Section 3 extends this algorithm so that it works on general settings. Section 4 discusses the complexity and the completeness of the extended algorithm. Section 5 illustrates the experimental result. Finally Section 6 brings the conclusion.

\section{Algorithm}

\subsection{Preliminaries}

The input for our algorithm is a set of Horn clauses. They contain linear inequalities on real numbers and unknown predicate symbols. With having real numbers $n$ and variables $v$, the syntax is defined as follows. Predicate symbols $P$ are represented by capital alphabet through this paper.

\setlength{\grammarindent}{6em}
\begin{grammar}

<t> ::= $n$ | $nv$ | $t + t$

<e> ::= $t \leq 0$ | $e \wedge e$

<p> ::= $P (v, v, ... )$

<x> ::= $e$ | $p$  % Horn term

<h> ::= $x \wedge x \wedge \cdots \longrightarrow x$

\end{grammar}

Although we limit the input only to linear inequalities with $\leq$, we will later extend to any linear arithmetic expressions by introducing disjunctions in $e$.

\subsection{Generating a implication tree}

By receiving Horn clauses as an input for the algorithm, we build a
implication tree.

---
Def <Implication Tree>:
Implication tree is such a tree that every node is labeled by a Horn term. As the semantics of the tree, the Horn term of every node is implied by the conjunction of its children's Horn terms.
---

In the implication tree, every relationship from a certain node to its children corresponds to one Horn clause of the original input. All leaves and the root node have linear expressions $e$ while all other have predicate symbols $p$. Therefore

We show the pseudo code for generating a tree.

\begin{algorithm}
\caption{$\mbox{\sc BuildTree}$}
\begin{algorithmic}
\item pseudo-code
\end{algorithmic}
\end{algorithm}

While building a tree, renaming should be accordingly to make the construct.

* Renaming?

\subsection{Application of Farkas' Lemma}

Correct statement of Farkas' Lemma
Relationship to Craig's Interpolation.

\subsection{Solution space representation}


\section{Extensions}

\subsection{Extension to DAG structure}

* Building graph

* Splitting a graph into tree

* Merging with the same-name predicate conjunctively

\subsection{Linear arithmetics with disjunction}

In the previous section, we assumed that the input inequalities are
conjunctively connected.

* Why do we need this extension? *

We extend our inequalities to include disjunctions in the linear
equations.

\setlength{\grammarindent}{2em}
\begin{grammar}
<la> ::= <expr> | $<la> \wedge <la>$ | $<la> \vee <la>$
\end{grammar}

* Predicates on the direct path from the leaf with disjunction to the
root are connected by disjunction
* Other predicates are connected by conjunction


* Why do we process LA-disjunction before DAG?
** DAG to LA-Disjunction are invalid???


\subsection{Merging of pred-pred}

* Simplification between clauses


\subsection{General Horn clauses with Loops}

No limitation Horn clause solving

* Merging pred-pred between looped same name


\section{Completeness and Complexity}

?

\section{Experiment}

We limited to integer space

\section{Future Work}
\section{Conclusion}

\bibliographystyle{plain}
\bibliography{./biblio}

\end{document}
