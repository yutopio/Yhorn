\documentclass{llncs}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{syntax}

\title{Solving Horn clauses over LI}
\author{Yuto Takei}
\institute{The University of Tokyo}

\begin{document}
\maketitle
\begin{abstract}
  This is the abstract.
\end{abstract}

\section{Introduction}


* Formal verification
--> Dependent typing of SHP
--> Horn clauses

* Some
Background for Horn clause solving
* Dependent type determination

Horn clause solving is a problem of constraint solving that is consisted of multiple Horn clauses with unknown predicate symbols. The solution is an assignment for such symbols so that all given Horn clauses stay valid. There may be multiple solutions for one problem, and the algorithm is expected to show at least one.

In this paper, we present a novel algorithm to solve Horn clauses. As the unique feature of the algorithm, we preserve the solution space throughout the computation. We are able to provide multiple assignments for predicate symbols. Additionally, this technique enables us to handle general Horn clauses rather than the recursion-free ones, which was the major restriction of the previous work.

The rest of our paper is structured as follows: Section 2 shows the basic algorithm to solve recursion-free Horn clauses with solution space consideration. Section 3 extends this algorithm so that it works on general settings. Section 4 discusses the complexity and the completeness of the extended algorithm. Section 5 illustrates the experimental result. Finally Section 6 brings the conclusion.

\section{Algorithm}

\subsection{Preliminaries}



\setlength{\grammarindent}{6em}
\begin{grammar}

<t> ::= $n$ | $nv$ | $t + t$

<e> ::= $t \leq 0$ | $e \wedge e$

<p> ::= $P (v, v, ... )$

<x> ::= $e$ | $p$

<h> ::= $x \wedge x \wedge \cdots \longrightarrow x$

\end{grammar}



* We consider inequalities.
** NOTE: Even we have =, $\neq$, >, <=, we can normalize to >=
         over integer space



\subsection{Generating a tree}

By receiving Horn clauses as an input for the algorithm, we build a
implication tree.

Def <Implication Tree>:

Implication tree is such a tree that every node is labeled by logical
atoms. The label of every node is implied by the conjunction of its
children's label.


* Renaming?

\subsection{Application of Farkas' Lemma}

Correct statement of Farkas' Lemma
Relationship to Craig's Interpolation.

\subsection{Solution space representation}


\section{Extensions}

\subsection{Extension to DAG structure}

* Building graph

* Splitting a graph into tree

* Merging with the same-name predicate conjunctively

\subsection{Linear arithmetics with disjunction}

In the previous section, we assumed that the input inequalities are
conjunctively connected.

* Why do we need this extension? *

We extend our inequalities to include disjunctions in the linear
equations.

\setlength{\grammarindent}{2em}
\begin{grammar}
<la> ::= <expr> | $<la> \wedge <la>$ | $<la> \vee <la>$
\end{grammar}

* Predicates on the direct path from the leaf with disjunction to the
root are connected by disjunction
* Other predicates are connected by conjunction


* Why do we process LA-disjunction before DAG?
** DAG to LA-Disjunction are invalid???


\subsection{Merging of pred-pred}

* Simplification between clauses


\subsection{General Horn clauses with Loops}

No limitation Horn clause solving

* Merging pred-pred between looped same name


\section{Completeness and Complexity}

?

\section{Experiment}

We limited to integer space

\section{Future Work}
\section{Conclusion}

\bibliographystyle{plain}
\bibliography{./biblio}

\end{document}
