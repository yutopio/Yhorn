MoCHi: Model Checker for Higher-Order Programs
  TRecS version: 1.30
  OCaml version: 4.00.1
  Command: ../mochi.opt -yhorn fact_exn.ml

parsed::
 let rec fact_1030 n_1031 exn_1032 =
   if n_1031 <= 0 then
     exn_1032 0
   else
     let exn_1033 n_1034 = if n_1034 = 0 then
                             1
                           else
                             exn_1032 n_1034 
     in
       n_1031 * fact_1030 (n_1031 - 1) exn_1033 
 in
 let exn_1035 n_1036 = let u_1066 = let u_1065 = {fail} () 
                                    in
                                      _|_ 
                       in
                         1 
 in
 let main_1037 n_1038 = if n_1038 > 0 then
                          let u_1076 = fact_1030 n_1038 exn_1035 
                          in
                            ()
                        else
                          () 
 in
   ()

set_target::
 let rec fact_1030 n_1031 exn_1032 =
   if n_1031 <= 0 then
     exn_1032 0
   else
     let exn_1033 n_1034 = if n_1034 = 0 then
                             1
                           else
                             exn_1032 n_1034 
     in
       n_1031 * fact_1030 (n_1031 - 1) exn_1033 
 in
 let exn_1035 n_1036 = let u_1066 = let u_1065 = {fail} () 
                                    in
                                      _|_ 
                       in
                         1 
 in
 let main_1037 n_1038 = if n_1038 > 0 then
                          let u_1076 = fact_1030 n_1038 exn_1035 
                          in
                            ()
                        else
                          () 
 in
 let main_1078 = let arg1_1077 = rand_int () 
                 in
                   main_1037 arg1_1077 
 in
   ()

copy_poly::
 let rec fact_1030 (n_1031:int) (exn_1032:(int -> int)) =
   if n_1031 <= 0 then
     exn_1032 0
   else
     let exn_1033 (n_1034:int) = if n_1034 = 0 then
                                   1
                                 else
                                   exn_1032 n_1034 
     in
       n_1031 * fact_1030 (n_1031 - 1) exn_1033 
 in
 let exn_1079 (n_1036:int) = let u_1066 = let u_1065 = {fail} () 
                                          in
                                            _|_ 
                             in
                               1 
 in
 let main_1037 (n_1038:int) = if n_1038 > 0 then
                                let u_1076 = fact_1030 n_1038 exn_1079 
                                in
                                  ()
                              else
                                () 
 in
 let main_1078 = let arg1_1077 = rand_int () 
                 in
                   main_1037 arg1_1077 
 in
   ()

CPS::
 let rec fact_1030 (n_1031:int) (exn_1032:(int -> ((int -> X) -> X))) (k_fact_1119:(
   int -> X)) =
   if n_1031 <= 0 then
     exn_1032 0 k_fact_1119
   else
     let exn_1033 (n_1034:int) (k_fact_exn_1143:(int -> X)) =
       if n_1034 = 0 then
         k_fact_exn_1143 1
       else
         exn_1032 n_1034 k_fact_exn_1143 
     in
       fact_1030 (n_1031 - 1) exn_1033 (fun x_1161 -> k_fact_1119 (n_1031 * x_1161)) 
 in
 let exn_1079 (n_1036:int) (k_exn_1202:(int -> X)) = {|fail|} () (fun x_1208 -> _|_) 
 in
 let main_1037 (n_1038:int) (k_main_1231:(unit -> X)) =
   if n_1038 > 0 then
     fact_1030 n_1038 exn_1079 (fun x_1234 -> k_main_1231 ())
   else
     k_main_1231 () 
 in
   rand_int_cps () (fun x_1267 -> main_1037 x_1267 (fun x_1264 -> end))

Program with abstraction types (CEGAR-cycle 0)::
Main: main_1292
  main_1292 -> (rand_int f_1296)
  exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 when (n_1034 = 0) -> (k_fact_exn_1143 1)
  exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 when (not (n_1034 = 0)) -> (exn_1032 n_1034 k_fact_exn_1143)
  exn_1079 n_1036 k_exn_1202 -> {fail} => (f_exn_1294 n_1036 ())
  f_1296 x_1267 -> (main_1037 x_1267 (f_1297 x_1267))
  f_1297 x_1267 x_1264 -> end
  f_exn_1294 n_1036 x_1208 -> _|_
  f_fact_1293 n_1031 k_fact_1119 x_1161 -> (k_fact_1119 (n_1031 * x_1161))
  f_main_1295 n_1038 k_main_1231 x_1234 -> (k_main_1231 ())
  fact_1030 n_1031 exn_1032 k_fact_1119 when (n_1031 <= 0) -> (exn_1032 0 k_fact_1119)
  fact_1030 n_1031 exn_1032 k_fact_1119 when (not (n_1031 <= 0)) ->
      (fact_1030 (n_1031 - 1) (exn_1033 n_1031 exn_1032) (f_fact_1293 n_1031 k_fact_1119))
  main_1037 n_1038 k_main_1231 when (n_1038 > 0) -> (fact_1030 n_1038 exn_1079 (f_main_1295 n_1038 k_main_1231))
  main_1037 n_1038 k_main_1231 when (not (n_1038 > 0)) -> (k_main_1231 ())
Types:
  main_1292 : X
  exn_1079 : (int -> (int -> X) -> X)
  fact_1030 : (int -> (int -> (int -> X) -> X) -> (int -> X) -> X)
  
(0-1) Abstracting ... DONE!

(0-2) Checking HORS ... DONE!

Error trace::
  main_1292 ... --> 
  f_1296 ... --> 
  main_1037 [1/2] ... --> 
  fact_1030 [1/2] ... --> 
  exn_1079 ... --> fail -->
  ERROR!

Spurious counter-example::
  0; 0; 0; 0; 0

(0-3) Checking counter-example ... DONE!

(0-4) Discovering predicates ... 
begin AbsTypeInfer.refine(95)[1]
  program:
    main_1292  | true = ((Random.int 0) f_1296)
    exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 | (n_1034 = 0) = (
    k_fact_exn_1143 1)
    exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 | (not (n_1034 = 0)) = (
    exn_1032 n_1034
             k_fact_exn_1143)
    exn_1079 n_1036 k_exn_1202 | true = (fail ())
    f_1296 x_1267 | true = (main_1037 x_1267
                                      (f_1297 x_1267))
    f_1297 x_1267 x_1264 | true = end
    f_exn_1294 n_1036 x_1208 | true = bot
    f_fact_1293 n_1031 k_fact_1119 x_1161 | true = (k_fact_1119 (n_1031 * x_1161))
    f_main_1295 n_1038 k_main_1231 x_1234 | true = (k_main_1231 ())
    fact_1030 n_1031 exn_1032 k_fact_1119 | (n_1031 <= 0) = (exn_1032 0
                                                                    k_fact_1119)
    fact_1030 n_1031 exn_1032 k_fact_1119 | (not (n_1031 <= 0)) = (fact_1030
                                                                    (
                                                                    n_1031 - 1)
                                                                    (
                                                                    exn_1033 n_1031
                                                                    exn_1032)
                                                                    (
                                                                    f_fact_1293 n_1031
                                                                    k_fact_1119))
    main_1037 n_1038 k_main_1231 | (n_1038 > 0) = (fact_1030 n_1038
                                                             exn_1079
                                                             (f_main_1295 n_1038
                                                                    k_main_1231))
    main_1037 n_1038 k_main_1231 | (not (n_1038 > 0)) = (k_main_1231 ())
    main_1292:X
    exn_1033:int -> (int -> (int -> X) -> X) -> int -> (int -> X) -> X
    exn_1079:int -> (int -> X) -> X
    f_1296:int -> X
    f_1297:int -> unit -> X
    f_exn_1294:int -> unit -> X
    f_fact_1293:int -> (int -> X) -> int -> X
    f_main_1295:int -> (unit -> X) -> int -> X
    fact_1030:int -> (int -> (int -> X) -> X) -> (int -> X) -> X
    main_1037:int -> (unit -> X) -> X
  inlined functions: exn_1033,f_1296,f_1297,f_exn_1294,f_fact_1293,f_main_1295,main_1037
  counterexample: 0:0:0:0:0
  error traces:
    [true.nop(<f_1296@4:0> = var2)
     [true.(<main_1037@6:0> = <f_1296@4:0>)
      [(<main_1037@6:0> > 0).(<fact_1030@9:0> = <main_1037@6:0>)
       [(<fact_1030@9:0> <= 0).(<<fact_1030@9:1>@12:0> = 0)[true.(<exn_1079@14:0> = <<fact_1030@9:1>@12:0>)[true.error
  begin RefTypeInfer.infer_etrs(96)[2]
    horn clauses:
      P[<exn_1079@14:0>](<exn_1079@14:0>:int)|- bot
      
      P[<main_1037@6:0>](<fact_1030@9:0>:int),
      P[<<fact_1030@9:1>@12:0>](<fact_1030@9:0>:int,<exn_1079@14:0>:int), (
      <fact_1030@9:0> > 0) |- P[<exn_1079@14:0>](<exn_1079@14:0>:int)
      
      P[<fact_1030@9:0>](<fact_1030@9:0>:int), ((<<fact_1030@9:1>@12:0> = 0) && (<fact_1030@9:0> <= 0))
      |- P[<<fact_1030@9:1>@12:0>](<fact_1030@9:0>:int,<<fact_1030@9:1>@12:0>:int)
      
      P[<main_1037@6:0>](<fact_1030@9:0>:int), (<fact_1030@9:0> > 0) |- P[<fact_1030@9:0>](<fact_1030@9:0>:int)
      
      P[<f_1296@4:0>](<main_1037@6:0>:int)|- P[<main_1037@6:0>](<main_1037@6:0>:int)
      
      |- P[<f_1296@4:0>](<f_1296@4:0>:int)
    call trees:
      <main_1292@1>
        <f_1296@4>
          <main_1037@6>
            <fact_1030@9>
            </<fact_1030@9:1>@12>
            <exn_1079@14>
    inlined horn clauses:
      P[<exn_1079@14:0>](<exn_1079@14:0>:int)|- bot
      
      P[<<fact_1030@9:1>@12:0>](<fact_1030@9:0>:int,<exn_1079@14:0>:int), (
      <fact_1030@9:0> > 0) |- P[<exn_1079@14:0>](<exn_1079@14:0>:int)
      
      P[<fact_1030@9:0>](<fact_1030@9:0>:int), ((<<fact_1030@9:1>@12:0> = 0) && (<fact_1030@9:0> <= 0))
      |- P[<<fact_1030@9:1>@12:0>](<fact_1030@9:0>:int,<<fact_1030@9:1>@12:0>:int)
      
       (<fact_1030@9:0> > 0) |- P[<fact_1030@9:0>](<fact_1030@9:0>:int)
    begin ParamSubstInfer.infer(700)[3]
      
    end ParamSubstInfer.infer(700)[3] (0.014997 sec.)
    inferred extra parameters:
      
    begin RefTypeInfer.elim_coeffs(702)[3]
      
    end RefTypeInfer.elim_coeffs(702)[3] (0.000000 sec.)
    begin YhornInterface.solve(823)[3]
      begin HcSolver.solve_ub(824)[4]
        encoded:
          P[<exn_1079@14:0>](<exn_1079@14:0>:int)|- bot
          
          P[<<fact_1030@9:1>@12:0>](<fact_1030@9:0>:int,<exn_1079@14:0>:int), (
          <fact_1030@9:0> > 0) |- P[<exn_1079@14:0>](<exn_1079@14:0>:int)
          
          P[<fact_1030@9:0>](<fact_1030@9:0>:int), ((<<fact_1030@9:1>@12:0> = 0) && (<fact_1030@9:0> <= 0))
          |- P[<<fact_1030@9:1>@12:0>](<fact_1030@9:0>:int,<<fact_1030@9:1>@12:0>:int)
          
           (<fact_1030@9:0> > 0) |- P[<fact_1030@9:0>](<fact_1030@9:0>:int)
        input to Yhorn:
          P[<exn_1079@14:0>](<exn_1079@14:0>:int)|- bot
          
          P[<<fact_1030@9:1>@12:0>](<fact_1030@9:0>:int,<exn_1079@14:0>:int), (
          <fact_1030@9:0> > 0) |- P[<exn_1079@14:0>](<exn_1079@14:0>:int)
          
          P[<fact_1030@9:0>](<fact_1030@9:0>:int), ((<fact_1030@9:0> <= 0) && (<<fact_1030@9:1>@12:0> = 0))
          |- P[<<fact_1030@9:1>@12:0>](<fact_1030@9:0>:int,<<fact_1030@9:1>@12:0>:int)
          Yhorn (Wed Sep 25 10:52:05 JST 2013)


(0=0) & (v_sep_exn_1079_sep_14_sep_0($4)) -> 1=0.
($5>0) & (v_sep_fact_1030_sep_9_sep_1_sep_12_sep_0($5,$4)) -> v_sep_exn_1079_sep_14_sep_0($4).
(($6=0) & ($5<=0)) & (v_sep_fact_1030_sep_9_sep_0($5)) -> v_sep_fact_1030_sep_9_sep_1_sep_12_sep_0($5,$6).
$5>0 -> v_sep_fact_1030_sep_9_sep_0($5).


v_sep_exn_1079_sep_14_sep_0: X
v_sep_fact_1030_sep_9_sep_0: X
v_sep_fact_1030_sep_9_sep_1_sep_12_sep_0: X
....
v_sep_exn_1079_sep_14_sep_0: X
v_sep_fact_1030_sep_9_sep_0: X
v_sep_fact_1030_sep_9_sep_1_sep_12_sep_0: X
...
v_sep_exn_1079_sep_14_sep_0: X
v_sep_fact_1030_sep_9_sep_0: X
v_sep_fact_1030_sep_9_sep_1_sep_12_sep_0: X
....
v_sep_exn_1079_sep_14_sep_0: X
v_sep_fact_1030_sep_9_sep_0: X
v_sep_fact_1030_sep_9_sep_1_sep_12_sep_0: X
....(0=0) & (v_sep_exn_1079_sep_14_sep_0($4)) -> 1=0.
($5>0) & (v_sep_fact_1030_sep_9_sep_1_sep_12_sep_0($5,$4)) -> v_sep_exn_1079_sep_14_sep_0($4).
(($6=0) & ($5<=0)) & (v_sep_fact_1030_sep_9_sep_0($5)) -> v_sep_fact_1030_sep_9_sep_1_sep_12_sep_0($5,$6).
$5>0 -> v_sep_fact_1030_sep_9_sep_0($5).

           (<fact_1030@9:0> > 0) |- P[<fact_1030@9:0>](<fact_1030@9:0>:int)
        solution:
          P[<exn_1079@14:0>]($7:int) = false
          P[<fact_1030@9:0>]($15:int) = true
          P[<<fact_1030@9:1>@12:0>]($10:int,$12:int) = ($10 <= 0)
        
      end HcSolver.solve_ub(824)[4] (0.014998 sec.)
      begin HcSolver.check_validity(897)[4]
        input:
          P[<exn_1079@14:0>](<exn_1079@14:0>:int)|- bot
          
          P[<<fact_1030@9:1>@12:0>](<fact_1030@9:0>:int,<exn_1079@14:0>:int), (
          <fact_1030@9:0> > 0) |- P[<exn_1079@14:0>](<exn_1079@14:0>:int)
          
          P[<fact_1030@9:0>](<fact_1030@9:0>:int), ((<<fact_1030@9:1>@12:0> = 0) && (<fact_1030@9:0> <= 0))
          |- P[<<fact_1030@9:1>@12:0>](<fact_1030@9:0>:int,<<fact_1030@9:1>@12:0>:int)
          
           (<fact_1030@9:0> > 0) |- P[<fact_1030@9:0>](<fact_1030@9:0>:int)
        checking substituted Horn clause:
           false |- bot
        checking substituted Horn clause:
           false |- bot
        checking substituted Horn clause:
           false |- bot
        checking substituted Horn clause:
           false |- bot
        
      end HcSolver.check_validity(897)[4] (0.000999 sec.)
      solution:
        P[<exn_1079@14:0>]($7:int) = false
        P[<fact_1030@9:0>]($15:int) = true
        P[<<fact_1030@9:1>@12:0>]($10:int,$12:int) = ($10 <= 0)
    end YhornInterface.solve(823)[3] (0.016997 sec.)
    
  end RefTypeInfer.infer_etrs(96)[2] (0.035993 sec.)
  refinement types:
    main_1292: X
    f_1296: v1:int -> X
    main_1037: v1:int -> (v2:unit -> X) -> X
    fact_1030: v1:int -> (v2:{v2:int | (v1 <= 0)} -> (v3:int -> X) -> X) -> (v6:int -> X) -> X
    exn_1079: v1:{v1:int | false} -> (v2:int -> X) -> X
    exn_1033: var19:int -> (var18:int -> (var17:int -> X) -> X) -> var14:int -> (var13:int -> X) -> X
    f_1297: var22:int -> var21:unit -> X
    f_exn_1294: var25:int -> var24:unit -> X
    f_fact_1293: var30:int -> (var29:int -> X) -> var27:int -> X
    f_main_1295: var35:int -> (var34:unit -> X) -> var32:int -> X
  abstraction types:
    main_1292: X
    f_1296: v1:int -> X
    main_1037: v1:int -> (v2:unit -> X) -> X
    fact_1030: v1:int -> (v2:int[v2 -> (v1 <= 0)] -> (v3:int -> X) -> X) -> (v6:int -> X) -> X
    exn_1079: v1:int -> (v2:int -> X) -> X
    exn_1033: var19:int -> (var18:int -> (var17:int -> X) -> X) -> var14:int -> (var13:int -> X) -> X
    f_1297: var22:int -> var21:unit -> X
    f_exn_1294: var25:int -> var24:unit -> X
    f_fact_1293: var30:int -> (var29:int -> X) -> var27:int -> X
    f_main_1295: var35:int -> (var34:unit -> X) -> var32:int -> X
  
end AbsTypeInfer.refine(95)[1] (0.037993 sec.)
DONE!

Prefix of spurious counter-example::
0; 0; 0; 0

Program with abstraction types (CEGAR-cycle 1)::
Main: main_1292
  main_1292 -> (rand_int f_1296)
  exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 when (n_1034 = 0) -> (k_fact_exn_1143 1)
  exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 when (not (n_1034 = 0)) -> (exn_1032 n_1034 k_fact_exn_1143)
  exn_1079 n_1036 k_exn_1202 -> {fail} => (f_exn_1294 n_1036 ())
  f_1296 x_1267 -> (main_1037 x_1267 (f_1297 x_1267))
  f_1297 x_1267 x_1264 -> end
  f_exn_1294 n_1036 x_1208 -> _|_
  f_fact_1293 n_1031 k_fact_1119 x_1161 -> (k_fact_1119 (n_1031 * x_1161))
  f_main_1295 n_1038 k_main_1231 x_1234 -> (k_main_1231 ())
  fact_1030 n_1031 exn_1032 k_fact_1119 when (n_1031 <= 0) -> (exn_1032 0 k_fact_1119)
  fact_1030 n_1031 exn_1032 k_fact_1119 when (not (n_1031 <= 0)) ->
      (fact_1030 (n_1031 - 1) (exn_1033 n_1031 exn_1032) (f_fact_1293 n_1031 k_fact_1119))
  main_1037 n_1038 k_main_1231 when (n_1038 > 0) -> (fact_1030 n_1038 exn_1079 (f_main_1295 n_1038 k_main_1231))
  main_1037 n_1038 k_main_1231 when (not (n_1038 > 0)) -> (k_main_1231 ())
Types:
  main_1292 : X
  exn_1079 : (int -> (int -> X) -> X)
  fact_1030 : (x_1:int -> (int[x_1 <= 0] -> (int -> X) -> X) -> (int -> X) -> X)
  
(1-1) Abstracting ... DONE!

(1-2) Checking HORS ... DONE!

Filter option enabled.
Restart CEGAR-loop.
Program with abstraction types (CEGAR-cycle 2)::
Main: main_1292
  main_1292 -> (rand_int f_1296)
  exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 when (n_1034 = 0) -> (k_fact_exn_1143 1)
  exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 when (not (n_1034 = 0)) -> (exn_1032 n_1034 k_fact_exn_1143)
  exn_1079 n_1036 k_exn_1202 -> {fail} => (f_exn_1294 n_1036 ())
  f_1296 x_1267 -> (main_1037 x_1267 (f_1297 x_1267))
  f_1297 x_1267 x_1264 -> end
  f_exn_1294 n_1036 x_1208 -> _|_
  f_fact_1293 n_1031 k_fact_1119 x_1161 -> (k_fact_1119 (n_1031 * x_1161))
  f_main_1295 n_1038 k_main_1231 x_1234 -> (k_main_1231 ())
  fact_1030 n_1031 exn_1032 k_fact_1119 when (n_1031 <= 0) -> (exn_1032 0 k_fact_1119)
  fact_1030 n_1031 exn_1032 k_fact_1119 when (not (n_1031 <= 0)) ->
      (fact_1030 (n_1031 - 1) (exn_1033 n_1031 exn_1032) (f_fact_1293 n_1031 k_fact_1119))
  main_1037 n_1038 k_main_1231 when (n_1038 > 0) -> (fact_1030 n_1038 exn_1079 (f_main_1295 n_1038 k_main_1231))
  main_1037 n_1038 k_main_1231 when (not (n_1038 > 0)) -> (k_main_1231 ())
Types:
  main_1292 : X
  exn_1079 : (int -> (int -> X) -> X)
  fact_1030 : (x_1:int -> (int[x_1 <= 0] -> (int -> X) -> X) -> (int -> X) -> X)
  
(2-1) Abstracting ... DONE!

(2-2) Checking HORS ... DONE!

Error trace::
  main_1292 ... --> 
  f_1296 ... --> 
  main_1037 [1/2] ... --> 
  fact_1030 [2/2] ... --> 
  fact_1030 [1/2] ... --> 
  exn_1033 [2/2] ... --> 
  exn_1079 ... --> fail -->
  ERROR!

Spurious counter-example::
  0; 0; 0; 1; 0; 1; 0

(2-3) Checking counter-example ... DONE!

(2-4) Discovering predicates ... 
begin AbsTypeInfer.refine(1349)[1]
  program:
    main_1292  | true = ((Random.int 0) f_1296)
    exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 | (n_1034 = 0) = (
    k_fact_exn_1143 1)
    exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 | (not (n_1034 = 0)) = (
    exn_1032 n_1034
             k_fact_exn_1143)
    exn_1079 n_1036 k_exn_1202 | true = (fail ())
    f_1296 x_1267 | true = (main_1037 x_1267
                                      (f_1297 x_1267))
    f_1297 x_1267 x_1264 | true = end
    f_exn_1294 n_1036 x_1208 | true = bot
    f_fact_1293 n_1031 k_fact_1119 x_1161 | true = (k_fact_1119 (n_1031 * x_1161))
    f_main_1295 n_1038 k_main_1231 x_1234 | true = (k_main_1231 ())
    fact_1030 n_1031 exn_1032 k_fact_1119 | (n_1031 <= 0) = (exn_1032 0
                                                                    k_fact_1119)
    fact_1030 n_1031 exn_1032 k_fact_1119 | (not (n_1031 <= 0)) = (fact_1030
                                                                    (
                                                                    n_1031 - 1)
                                                                    (
                                                                    exn_1033 n_1031
                                                                    exn_1032)
                                                                    (
                                                                    f_fact_1293 n_1031
                                                                    k_fact_1119))
    main_1037 n_1038 k_main_1231 | (n_1038 > 0) = (fact_1030 n_1038
                                                             exn_1079
                                                             (f_main_1295 n_1038
                                                                    k_main_1231))
    main_1037 n_1038 k_main_1231 | (not (n_1038 > 0)) = (k_main_1231 ())
    main_1292:X
    exn_1033:int -> (int -> (int -> X) -> X) -> int -> (int -> X) -> X
    exn_1079:int -> (int -> X) -> X
    f_1296:int -> X
    f_1297:int -> unit -> X
    f_exn_1294:int -> unit -> X
    f_fact_1293:int -> (int -> X) -> int -> X
    f_main_1295:int -> (unit -> X) -> int -> X
    fact_1030:int -> (int -> (int -> X) -> X) -> (int -> X) -> X
    main_1037:int -> (unit -> X) -> X
  inlined functions: exn_1033,f_1296,f_1297,f_exn_1294,f_fact_1293,f_main_1295,main_1037
  counterexample: 0:0:0:1:0:1:0
  error traces:
    [true.nop(<f_1296@20:0> = var36)
     [true.(<main_1037@22:0> = <f_1296@20:0>)
      [(<main_1037@22:0> > 0).(<fact_1030@25:0> = <main_1037@22:0>)
       [(not (<fact_1030@25:0> <= 0)).(<fact_1030@28:0> = (<fact_1030@25:0> - 1))
        [(<fact_1030@28:0> <= 0).(<<fact_1030@28:1>@31:0> = 0)
         [true.((<exn_1033@33:0> = <fact_1030@25:0>) && (<exn_1033@33:2> = <<fact_1030@28:1>@31:0>))
          [(not (<exn_1033@33:2> = 0)).(<<exn_1033@33:1>@36:0> = <exn_1033@33:2>)
           [true.(<<fact_1030@25:1>@38:0> = <<exn_1033@33:1>@36:0>)
            [true.(<exn_1079@40:0> = <<fact_1030@25:1>@38:0>)[true.error
  begin RefTypeInfer.infer_etrs(1350)[2]
    horn clauses:
      P[<exn_1079@40:0>](<exn_1079@40:0>:int)|- bot
      
      P[<main_1037@22:0>](<fact_1030@25:0>:int),
      P[<<fact_1030@25:1>@38:0>](<fact_1030@25:0>:int,<exn_1079@40:0>:int), (
      <fact_1030@25:0> > 0) |- P[<exn_1079@40:0>](<exn_1079@40:0>:int)
      
      P[<fact_1030@25:0>](<fact_1030@25:0>:int),
      P[<<exn_1033@33:1>@36:0>](<fact_1030@25:0>:int,<<fact_1030@25:1>@38:0>:int), (
      <fact_1030@25:0> > 0) |- P[<<fact_1030@25:1>@38:0>](<fact_1030@25:0>:int,
                                                          <<fact_1030@25:1>@38:0>:int)
      
      P[<exn_1033@33:2>](<exn_1033@33:0>:int,<<exn_1033@33:1>@36:0>:int), (
      <<exn_1033@33:1>@36:0> <> 0) |- P[<<exn_1033@33:1>@36:0>](<exn_1033@33:0>:int,
                                                                <<exn_1033@33:1>@36:0>:int)
      
      P[<fact_1030@25:0>](<exn_1033@33:0>:int),
      P[<<fact_1030@28:1>@31:0>]((-1 + <exn_1033@33:0>):int,<exn_1033@33:2>:int), (
      <exn_1033@33:0> > 0) |- P[<exn_1033@33:2>](<exn_1033@33:0>:int,
                                                 <exn_1033@33:2>:int)
      
      P[<fact_1030@28:0>](<fact_1030@28:0>:int), ((<<fact_1030@28:1>@31:0> = 0) && (<fact_1030@28:0> <= 0))
      |- P[<<fact_1030@28:1>@31:0>](<fact_1030@28:0>:int,<<fact_1030@28:1>@31:0>:int)
      
      P[<fact_1030@25:0>]((1 + <fact_1030@28:0>):int), ((1 + <fact_1030@28:0>) > 0)
      |- P[<fact_1030@28:0>](<fact_1030@28:0>:int)
      
      P[<main_1037@22:0>](<fact_1030@25:0>:int), (<fact_1030@25:0> > 0) |- P[<fact_1030@25:0>](<fact_1030@25:0>:int)
      
      P[<f_1296@20:0>](<main_1037@22:0>:int)|- P[<main_1037@22:0>](<main_1037@22:0>:int)
      
      |- P[<f_1296@20:0>](<f_1296@20:0>:int)
    call trees:
      <main_1292@17>
        <f_1296@20>
          <main_1037@22>
            <fact_1030@25>
              <fact_1030@28>
              </<fact_1030@28:1>@31>
              <exn_1033@33>
              </<exn_1033@33:1>@36>
            </<fact_1030@25:1>@38>
            <exn_1079@40>
    inlined horn clauses:
      P[<exn_1079@40:0>](<exn_1079@40:0>:int)|- bot
      
      P[<<fact_1030@25:1>@38:0>](<fact_1030@25:0>:int,<exn_1079@40:0>:int), (
      <fact_1030@25:0> > 0) |- P[<exn_1079@40:0>](<exn_1079@40:0>:int)
      
      P[<fact_1030@25:0>](<fact_1030@25:0>:int),
      P[<<fact_1030@28:1>@31:0>]((-1 + <fact_1030@25:0>):int,<<fact_1030@25:1>@38:0>:int),
      ((<<fact_1030@25:1>@38:0> <> 0) && (<fact_1030@25:0> > 0))
      |- P[<<fact_1030@25:1>@38:0>](<fact_1030@25:0>:int,<<fact_1030@25:1>@38:0>:int)
      
      P[<fact_1030@28:0>](<fact_1030@28:0>:int), ((<<fact_1030@28:1>@31:0> = 0) && (<fact_1030@28:0> <= 0))
      |- P[<<fact_1030@28:1>@31:0>](<fact_1030@28:0>:int,<<fact_1030@28:1>@31:0>:int)
      
      P[<fact_1030@25:0>]((1 + <fact_1030@28:0>):int), ((1 + <fact_1030@28:0>) > 0)
      |- P[<fact_1030@28:0>](<fact_1030@28:0>:int)
      
       (<fact_1030@25:0> > 0) |- P[<fact_1030@25:0>](<fact_1030@25:0>:int)
    begin ParamSubstInfer.infer(2564)[3]
      
    end ParamSubstInfer.infer(2564)[3] (0.030995 sec.)
    inferred extra parameters:
      
    begin RefTypeInfer.elim_coeffs(2566)[3]
      
    end RefTypeInfer.elim_coeffs(2566)[3] (0.002000 sec.)
    begin YhornInterface.solve(2775)[3]
      begin HcSolver.solve_ub(2776)[4]
        encoded:
          P[<exn_1079@40:0>](<exn_1079@40:0>:int)|- bot
          
          P[<<fact_1030@25:1>@38:0>](<fact_1030@25:0>:int,<exn_1079@40:0>:int), (
          <fact_1030@25:0> > 0) |- P[<exn_1079@40:0>](<exn_1079@40:0>:int)
          
          P[<fact_1030@25:0>](<fact_1030@25:0>:int),
          P[<<fact_1030@28:1>@31:0>]((-1 + <fact_1030@25:0>):int,<<fact_1030@25:1>@38:0>:int),
          ((<<fact_1030@25:1>@38:0> <> 0) && (<fact_1030@25:0> > 0))
          |- P[<<fact_1030@25:1>@38:0>](<fact_1030@25:0>:int,<<fact_1030@25:1>@38:0>:int)
          
          P[<fact_1030@28:0>](<fact_1030@28:0>:int), ((<<fact_1030@28:1>@31:0> = 0) && (<fact_1030@28:0> <= 0))
          |- P[<<fact_1030@28:1>@31:0>](<fact_1030@28:0>:int,<<fact_1030@28:1>@31:0>:int)
          
          P[<fact_1030@25:0>]((1 + <fact_1030@28:0>):int), ((1 + <fact_1030@28:0>) > 0)
          |- P[<fact_1030@28:0>](<fact_1030@28:0>:int)
          
           (<fact_1030@25:0> > 0) |- P[<fact_1030@25:0>](<fact_1030@25:0>:int)
        input to Yhorn:
          P[<exn_1079@40:0>](<exn_1079@40:0>:int)|- bot
          
          P[<<fact_1030@25:1>@38:0>](<fact_1030@25:0>:int,<exn_1079@40:0>:int), (
          <fact_1030@25:0> > 0) |- P[<exn_1079@40:0>](<exn_1079@40:0>:int)
          
          P[<fact_1030@25:0>](<fact_1030@25:0>:int),
          P[<<fact_1030@28:1>@31:0>](var37:int,<<fact_1030@25:1>@38:0>:int),
          (((1 + var37) = <fact_1030@25:0>) && ((<fact_1030@25:0> > 0) && (<<fact_1030@25:1>@38:0> <> 0)))
          |- P[<<fact_1030@25:1>@38:0>](<fact_1030@25:0>:int,<<fact_1030@25:1>@38:0>:int)
          
          P[<fact_1030@28:0>](<fact_1030@28:0>:int), ((<fact_1030@28:0> <= 0) && (<<fact_1030@28:1>@31:0> = 0))
          |- P[<<fact_1030@28:1>@31:0>](<fact_1030@28:0>:int,<<fact_1030@28:1>@31:0>:int)
          
          P[<fact_1030@25:0>](var38:int), ((var38 = (1 + <fact_1030@28:0>)) && ((1 + <fact_1030@28:0>) > 0))
          |- P[<fact_1030@28:0>](<fact_1030@28:0>:int)
          Yhorn (Wed Sep 25 10:52:05 JST 2013)


(0=0) & (v_sep_exn_1079_sep_40_sep_0($49)) -> 1=0.
($50>0) & (v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0($50,$49)) -> v_sep_exn_1079_sep_40_sep_0($49).
(($51<>0) & ($50>0) & (-$50+$52+1=0)) & (v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0($52,$51)) & (v_sep_fact_1030_sep_25_sep_0($50)) -> v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0($50,$51).
(($53=0) & ($54<=0)) & (v_sep_fact_1030_sep_28_sep_0($54)) -> v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0($54,$53).
(($54+1>0) & (-$54+$55-1=0)) & (v_sep_fact_1030_sep_25_sep_0($55)) -> v_sep_fact_1030_sep_28_sep_0($54).
$50>0 -> v_sep_fact_1030_sep_25_sep_0($50).


v_sep_exn_1079_sep_40_sep_0: X
v_sep_fact_1030_sep_25_sep_0: X
v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0: X
v_sep_fact_1030_sep_28_sep_0: X
v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0: X
.........Extend [20]0.248961
Reconstrcut: 4

v_sep_exn_1079_sep_40_sep_0: X
v_sep_fact_1030_sep_25_sep_0: X
v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0: X
v_sep_fact_1030_sep_28_sep_0: X
v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0: X
...Split disj [20] 0.249961
Reconstrcut: 5 **)

v_sep_exn_1079_sep_40_sep_0: X
v_sep_fact_1030_sep_25_sep_0: X
v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0: (X) | (X)
v_sep_fact_1030_sep_28_sep_0: X
v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0: X
........
v_sep_exn_1079_sep_40_sep_0: X
v_sep_fact_1030_sep_25_sep_0: X
v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0: (X) | (X)
v_sep_fact_1030_sep_28_sep_0: X
v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0: X
....
v_sep_exn_1079_sep_40_sep_0: X
v_sep_fact_1030_sep_25_sep_0: X
v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0: (X) | (X)
v_sep_fact_1030_sep_28_sep_0: X
v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0: X
........Split conj [22] 0.25796
(Reconstrcut: 10 **)
v_sep_exn_1079_sep_40_sep_0: X
v_sep_fact_1030_sep_25_sep_0: X
v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0: (X) | (X)
v_sep_fact_1030_sep_28_sep_0: X
v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0: (X) & (X)
..........
v_sep_exn_1079_sep_40_sep_0: X
v_sep_fact_1030_sep_25_sep_0: X
v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0: (X) | (X)
v_sep_fact_1030_sep_28_sep_0: X
v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0: (X) & (X)
....
v_sep_exn_1079_sep_40_sep_0: X
v_sep_fact_1030_sep_25_sep_0: X
v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0: (X) | (X)
v_sep_fact_1030_sep_28_sep_0: X
v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0: (X) & (X)
........
v_sep_exn_1079_sep_40_sep_0: X
v_sep_fact_1030_sep_25_sep_0: X
v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0: (X) | (X)
v_sep_fact_1030_sep_28_sep_0: X
v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0: (X) & (X)
..........
v_sep_exn_1079_sep_40_sep_0: X
v_sep_fact_1030_sep_25_sep_0: X
v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0: (X) | (X)
v_sep_fact_1030_sep_28_sep_0: X
v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0: (X) & (X)
...........(0=0) & (v_sep_exn_1079_sep_40_sep_0($49)) -> 1=0.
($50>0) & (v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0($50,$49)) -> v_sep_exn_1079_sep_40_sep_0($49).
(($51<>0) & ($50>0) & (-$50+$52+1=0)) & (v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0($52,$51)) & (v_sep_fact_1030_sep_25_sep_0($50)) -> v_sep_fact_1030_sep_25_sep_1_sep_38_sep_0($50,$51).
(($53=0) & ($54<=0)) & (v_sep_fact_1030_sep_28_sep_0($54)) -> v_sep_fact_1030_sep_28_sep_1_sep_31_sep_0($54,$53).
(($54+1>0) & (-$54+$55-1=0)) & (v_sep_fact_1030_sep_25_sep_0($55)) -> v_sep_fact_1030_sep_28_sep_0($54).
$50>0 -> v_sep_fact_1030_sep_25_sep_0($50).

           (<fact_1030@25:0> > 0) |- P[<fact_1030@25:0>](<fact_1030@25:0>:int)
        solution:
          P[<exn_1079@40:0>]($56:int) = false
          P[<fact_1030@25:0>]($69:int) = true
          P[<<fact_1030@25:1>@38:0>]($59:int,$61:int) = false
          P[<fact_1030@28:0>]($72:int) = true
          P[<<fact_1030@28:1>@31:0>]($64:int,$66:int) = ($66 = 0)
        
      end HcSolver.solve_ub(2776)[4] (0.034995 sec.)
      begin HcSolver.check_validity(2987)[4]
        input:
          P[<exn_1079@40:0>](<exn_1079@40:0>:int)|- bot
          
          P[<<fact_1030@25:1>@38:0>](<fact_1030@25:0>:int,<exn_1079@40:0>:int), (
          <fact_1030@25:0> > 0) |- P[<exn_1079@40:0>](<exn_1079@40:0>:int)
          
          P[<fact_1030@25:0>](<fact_1030@25:0>:int),
          P[<<fact_1030@28:1>@31:0>]((-1 + <fact_1030@25:0>):int,<<fact_1030@25:1>@38:0>:int),
          ((<<fact_1030@25:1>@38:0> <> 0) && (<fact_1030@25:0> > 0))
          |- P[<<fact_1030@25:1>@38:0>](<fact_1030@25:0>:int,<<fact_1030@25:1>@38:0>:int)
          
          P[<fact_1030@28:0>](<fact_1030@28:0>:int), ((<<fact_1030@28:1>@31:0> = 0) && (<fact_1030@28:0> <= 0))
          |- P[<<fact_1030@28:1>@31:0>](<fact_1030@28:0>:int,<<fact_1030@28:1>@31:0>:int)
          
          P[<fact_1030@25:0>]((1 + <fact_1030@28:0>):int), ((1 + <fact_1030@28:0>) > 0)
          |- P[<fact_1030@28:0>](<fact_1030@28:0>:int)
          
           (<fact_1030@25:0> > 0) |- P[<fact_1030@25:0>](<fact_1030@25:0>:int)
        checking substituted Horn clause:
           false |- bot
        checking substituted Horn clause:
           false |- bot
        checking substituted Horn clause:
           false |- bot
        checking substituted Horn clause:
           false |- bot
        checking substituted Horn clause:
           false |- bot
        checking substituted Horn clause:
           false |- bot
        
      end HcSolver.check_validity(2987)[4] (0.001000 sec.)
      solution:
        P[<exn_1079@40:0>]($56:int) = false
        P[<fact_1030@25:0>]($69:int) = true
        P[<<fact_1030@25:1>@38:0>]($59:int,$61:int) = false
        P[<fact_1030@28:0>]($72:int) = true
        P[<<fact_1030@28:1>@31:0>]($64:int,$66:int) = ($66 = 0)
    end YhornInterface.solve(2775)[3] (0.035995 sec.)
    
  end RefTypeInfer.infer_etrs(1350)[2] (0.075989 sec.)
  refinement types:
    main_1292: X
    f_1296: v1:int -> X
    main_1037: v1:int -> (v2:unit -> X) -> X
    fact_1030: v1:int -> (v2:{v2:int | false} -> (v3:int -> X) -> X) -> (v6:int -> X) -> X
    fact_1030: v1:int -> (v2:{v2:int | (v2 = 0)} -> (v3:int -> X) -> X) -> (v6:int -> X) -> X
    exn_1033: v1:int -> (v2:int -> (v3:int -> X) -> X) -> v6:int -> (v7:int -> X) -> X
    exn_1079: v1:{v1:int | false} -> (v2:int -> X) -> X
    f_1297: var57:int -> var56:unit -> X
    f_exn_1294: var60:int -> var59:unit -> X
    f_fact_1293: var65:int -> (var64:int -> X) -> var62:int -> X
    f_main_1295: var70:int -> (var69:unit -> X) -> var67:int -> X
  abstraction types:
    main_1292: X
    f_1296: v1:int -> X
    main_1037: v1:int -> (v2:unit -> X) -> X
    fact_1030: var71:int -> (var72:int[var72 -> (var72 = 0)] -> (var73:int -> X) -> X) -> (var76:int -> X) -> X
    exn_1033: v1:int -> (v2:int -> (v3:int -> X) -> X) -> v6:int -> (v7:int -> X) -> X
    exn_1079: v1:int -> (v2:int -> X) -> X
    f_1297: var57:int -> var56:unit -> X
    f_exn_1294: var60:int -> var59:unit -> X
    f_fact_1293: var65:int -> (var64:int -> X) -> var62:int -> X
    f_main_1295: var70:int -> (var69:unit -> X) -> var67:int -> X
  
end AbsTypeInfer.refine(1349)[1] (0.077988 sec.)
DONE!

Prefix of spurious counter-example::
0; 0; 0; 1; 0; 1

Program with abstraction types (CEGAR-cycle 3)::
Main: main_1292
  main_1292 -> (rand_int f_1296)
  exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 when (n_1034 = 0) -> (k_fact_exn_1143 1)
  exn_1033 n_1031 exn_1032 n_1034 k_fact_exn_1143 when (not (n_1034 = 0)) -> (exn_1032 n_1034 k_fact_exn_1143)
  exn_1079 n_1036 k_exn_1202 -> {fail} => (f_exn_1294 n_1036 ())
  f_1296 x_1267 -> (main_1037 x_1267 (f_1297 x_1267))
  f_1297 x_1267 x_1264 -> end
  f_exn_1294 n_1036 x_1208 -> _|_
  f_fact_1293 n_1031 k_fact_1119 x_1161 -> (k_fact_1119 (n_1031 * x_1161))
  f_main_1295 n_1038 k_main_1231 x_1234 -> (k_main_1231 ())
  fact_1030 n_1031 exn_1032 k_fact_1119 when (n_1031 <= 0) -> (exn_1032 0 k_fact_1119)
  fact_1030 n_1031 exn_1032 k_fact_1119 when (not (n_1031 <= 0)) ->
      (fact_1030 (n_1031 - 1) (exn_1033 n_1031 exn_1032) (f_fact_1293 n_1031 k_fact_1119))
  main_1037 n_1038 k_main_1231 when (n_1038 > 0) -> (fact_1030 n_1038 exn_1079 (f_main_1295 n_1038 k_main_1231))
  main_1037 n_1038 k_main_1231 when (not (n_1038 > 0)) -> (k_main_1231 ())
Types:
  main_1292 : X
  exn_1079 : (int -> (int -> X) -> X)
  fact_1030 : (x_1:int -> (x_3:int[x_3 = 0; x_1 <= 0] -> (int -> X) -> X) -> (int -> X) -> X)
  
(3-1) Abstracting ... DONE!

(3-2) Checking HORS ... DONE!

Safe!

Refinement Types:
  exn: Top
  fact: ((x_1:int -> (({x_4:int | x_1 <= 0} -> Bottom) -> int)) /\ (int -> (({0} -> int) -> int)))

cycles: 3
total: 0.365 sec
  abst: 0.009 sec
  mc: 0.031 sec
  refine: 0.129 sec
    exparam: 0.046 sec
