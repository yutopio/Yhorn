MoCHi: Model Checker for Higher-Order Programs
  TRecS version: 1.30
  OCaml version: 4.00.1
  Command: ../mochi.opt -yhorn bsearch.ml

parsed::
 let make_array_1030 n_1031 = n_1031 
 in
 let arraysize_1032 src_1033 = src_1033 
 in
 let update_1034 des_1035 i_1036 x_1037 = if 0 <= i_1036 && i_1036 < des_1035 then
                                            ()
                                          else
                                            {fail} () 
 in
 let sub_1038 src_1039 i_1040 = let u_1072 = if 0 <= i_1040 && i_1040 < src_1039 then
                                               ()
                                             else
                                               {fail} () 
                                in
                                  0 
 in
 let rec bs_aux_1041 key_1042 vec_1043 l_1044 u_1045 =
   if u_1045 < l_1044 then
     -1
   else
     let m_1046 = l_1044 + Pervasives./ (u_1045 - l_1044) 2 
     in
     let x_1047 = sub_1038 vec_1043 m_1046 
     in
       if x_1047 < key_1042 then
         bs_aux_1041 key_1042 vec_1043 (m_1046 + 1) u_1045
       else
         if x_1047 > key_1042 then
           bs_aux_1041 key_1042 vec_1043 l_1044 (m_1046 - 1)
         else
           m_1046 
 in
 let bsearch_1048 key_1049 vec_1050 = bs_aux_1041 key_1049 vec_1050 0 (arraysize_1032 vec_1050 - 1) 
 in
 let main_1051 n_1052 m_1053 =
   let v1_1054 = make_array_1030 n_1052 
   in
   let v2_1055 = make_array_1030 m_1053 
   in
     if 0 <= n_1052 && n_1052 = m_1053 then
       let u_1156 = bsearch_1048 v1_1054 v2_1055 
       in
         ()
     else
       () 
 in
   ()

set_target::
 let make_array_1030 n_1031 = n_1031 
 in
 let arraysize_1032 src_1033 = src_1033 
 in
 let update_1034 des_1035 i_1036 x_1037 = if 0 <= i_1036 && i_1036 < des_1035 then
                                            ()
                                          else
                                            {fail} () 
 in
 let sub_1038 src_1039 i_1040 = let u_1072 = if 0 <= i_1040 && i_1040 < src_1039 then
                                               ()
                                             else
                                               {fail} () 
                                in
                                  0 
 in
 let rec bs_aux_1041 key_1042 vec_1043 l_1044 u_1045 =
   if u_1045 < l_1044 then
     -1
   else
     let m_1046 = l_1044 + Pervasives./ (u_1045 - l_1044) 2 
     in
     let x_1047 = sub_1038 vec_1043 m_1046 
     in
       if x_1047 < key_1042 then
         bs_aux_1041 key_1042 vec_1043 (m_1046 + 1) u_1045
       else
         if x_1047 > key_1042 then
           bs_aux_1041 key_1042 vec_1043 l_1044 (m_1046 - 1)
         else
           m_1046 
 in
 let bsearch_1048 key_1049 vec_1050 = bs_aux_1041 key_1049 vec_1050 0 (arraysize_1032 vec_1050 - 1) 
 in
 let main_1051 n_1052 m_1053 =
   let v1_1054 = make_array_1030 n_1052 
   in
   let v2_1055 = make_array_1030 m_1053 
   in
     if 0 <= n_1052 && n_1052 = m_1053 then
       let u_1156 = bsearch_1048 v1_1054 v2_1055 
       in
         ()
     else
       () 
 in
 let main_1159 = let arg1_1157 = rand_int () 
                 in
                 let arg2_1158 = rand_int () 
                 in
                   main_1051 arg1_1157 arg2_1158 
 in
   ()

make_ext_funs::
 let Pervasives./_1160 (x_1161:int) (x_1162:int) = rand_int () 
 in
 let make_array_1030 (n_1031:!!!) = n_1031 
 in
 let arraysize_1032 (src_1033:!!!) = src_1033 
 in
 let update_1034 (des_1035:int) (i_1036:int) (x_1037:!!!) =
   if 0 <= i_1036 && i_1036 < des_1035 then
     ()
   else
     {fail} () 
 in
 let sub_1038 (src_1039:int) (i_1040:int) =
   let u_1072 = if 0 <= i_1040 && i_1040 < src_1039 then
                  ()
                else
                  {fail} () 
   in
     0 
 in
 let rec bs_aux_1041 (key_1042:int) (vec_1043:int) (l_1044:int) (u_1045:int) =
   if u_1045 < l_1044 then
     -1
   else
     let m_1046 = l_1044 + Pervasives./_1160 (u_1045 - l_1044) 2 
     in
     let x_1047 = sub_1038 vec_1043 m_1046 
     in
       if x_1047 < key_1042 then
         bs_aux_1041 key_1042 vec_1043 (m_1046 + 1) u_1045
       else
         if x_1047 > key_1042 then
           bs_aux_1041 key_1042 vec_1043 l_1044 (m_1046 - 1)
         else
           m_1046 
 in
 let bsearch_1048 (key_1049:int) (vec_1050:int) = bs_aux_1041 key_1049 vec_1050 0 (arraysize_1032 vec_1050 - 1) 
 in
 let main_1051 (n_1052:int) (m_1053:int) =
   let v1_1054 = make_array_1030 n_1052 
   in
   let v2_1055 = make_array_1030 m_1053 
   in
     if 0 <= n_1052 && n_1052 = m_1053 then
       let u_1156 = bsearch_1048 v1_1054 v2_1055 
       in
         ()
     else
       () 
 in
 let main_1159 = let arg1_1157 = rand_int () 
                 in
                 let arg2_1158 = rand_int () 
                 in
                   main_1051 arg1_1157 arg2_1158 
 in
   ()

copy_poly::
 let Pervasives./_1160 (x_1161:int) (x_1162:int) = rand_int () 
 in
 let make_array_1164 (n_1031:int) = n_1031 
 in
 let arraysize_1163 (src_1033:int) = src_1033 
 in
 let update_1034 (des_1035:int) (i_1036:int) (x_1037:unit) =
   if 0 <= i_1036 && i_1036 < des_1035 then
     ()
   else
     {fail} () 
 in
 let sub_1038 (src_1039:int) (i_1040:int) =
   let u_1072 = if 0 <= i_1040 && i_1040 < src_1039 then
                  ()
                else
                  {fail} () 
   in
     0 
 in
 let rec bs_aux_1041 (key_1042:int) (vec_1043:int) (l_1044:int) (u_1045:int) =
   if u_1045 < l_1044 then
     -1
   else
     let m_1046 = l_1044 + Pervasives./_1160 (u_1045 - l_1044) 2 
     in
     let x_1047 = sub_1038 vec_1043 m_1046 
     in
       if x_1047 < key_1042 then
         bs_aux_1041 key_1042 vec_1043 (m_1046 + 1) u_1045
       else
         if x_1047 > key_1042 then
           bs_aux_1041 key_1042 vec_1043 l_1044 (m_1046 - 1)
         else
           m_1046 
 in
 let bsearch_1048 (key_1049:int) (vec_1050:int) = bs_aux_1041 key_1049 vec_1050 0 (arraysize_1163 vec_1050 - 1) 
 in
 let main_1051 (n_1052:int) (m_1053:int) =
   let v1_1054 = make_array_1164 n_1052 
   in
   let v2_1055 = make_array_1164 m_1053 
   in
     if 0 <= n_1052 && n_1052 = m_1053 then
       let u_1156 = bsearch_1048 v1_1054 v2_1055 
       in
         ()
     else
       () 
 in
 let main_1159 = let arg1_1157 = rand_int () 
                 in
                 let arg2_1158 = rand_int () 
                 in
                   main_1051 arg1_1157 arg2_1158 
 in
   ()

CPS::
 let Pervasives./_1160 (x_1161:int) (x_1162:int) (k_Pervasives./_1193:(int -> X)) = rand_int_cps () k_Pervasives./_1193 
 in
 let make_array_1164 (n_1031:int) (k_make_array_1217:(int -> X)) = k_make_array_1217 n_1031 
 in
 let arraysize_1163 (src_1033:int) (k_arraysize_1231:(int -> X)) = k_arraysize_1231 src_1033 
 in
 let update_1034 (des_1035:int) (i_1036:int) (x_1037:unit) (k_update_1251:(
   unit -> X)) =
   let k_update_1254 (b_1266:bool) = if b_1266 then
                                       k_update_1251 ()
                                     else
                                       {|fail|} () k_update_1251 
   in
     if 0 <= i_1036 then
       k_update_1254 (i_1036 < des_1035)
     else
       k_update_1254 false 
 in
 let sub_1038 (src_1039:int) (i_1040:int) (k_sub_1283:(int -> X)) =
   let k_sub_u_1300 (x_1286:unit) = k_sub_1283 0 
   in
   let k_sub_u_1289 (b_1301:bool) = if b_1301 then
                                      k_sub_u_1300 ()
                                    else
                                      {|fail|} () k_sub_u_1300 
   in
     if 0 <= i_1040 then
       k_sub_u_1289 (i_1040 < src_1039)
     else
       k_sub_u_1289 false 
 in
 let rec bs_aux_1041 (key_1042:int) (vec_1043:int) (l_1044:int) (u_1045:int) (k_bs_aux_1324:(
   int -> X)) =
   if u_1045 < l_1044 then
     k_bs_aux_1324 -1
   else
     Pervasives./_1160 (u_1045 - l_1044) 2
       (fun x_1331 ->
          sub_1038 vec_1043 (l_1044 + x_1331)
            (fun x_1345 ->
               (if x_1345 < key_1042 then
                  bs_aux_1041 key_1042 vec_1043 ((l_1044 + x_1331) + 1) u_1045 k_bs_aux_1324
                else
                  if x_1345 > key_1042 then
                    bs_aux_1041 key_1042 vec_1043 l_1044 ((l_1044 + x_1331) - 1) k_bs_aux_1324
                  else
                    k_bs_aux_1324 (l_1044 + x_1331)))) 
 in
 let bsearch_1048 (key_1049:int) (vec_1050:int) (k_bsearch_1411:(int -> X)) =
   arraysize_1163 vec_1050 (fun x_1420 -> bs_aux_1041 key_1049 vec_1050 0 (x_1420 - 1) k_bsearch_1411) 
 in
 let main_1051 (n_1052:int) (m_1053:int) (k_main_1455:(unit -> X)) =
   make_array_1164 n_1052
     (fun x_1458 ->
        make_array_1164 m_1053
          (fun x_1471 ->
             (let k_main_1484 (b_1503:bool) =
                if b_1503 then
                  bsearch_1048 x_1458 x_1471 (fun x_1488 -> k_main_1455 ())
                else
                  k_main_1455 () 
              in
                if 0 <= n_1052 then
                  k_main_1484 (n_1052 = m_1053)
                else
                  k_main_1484 false))) 
 in
   rand_int_cps () (fun x_1509 -> rand_int_cps () (fun x_1522 -> main_1051 x_1509 x_1522 (fun x_1506 -> end)))

Program with abstraction types (CEGAR-cycle 0)::
Main: main_1554
  main_1554 -> (rand_int f_1561)
  Pervasives./_1160 x_1161 x_1162 k_Pervasives./_1193 -> (rand_int k_Pervasives./_1193)
  arraysize_1163 src_1033 k_arraysize_1231 -> (k_arraysize_1231 src_1033)
  br_f_bs_aux_1564 b_1565 key_1042 l_1044 u_1045 vec_1043 x_1331 k_bs_aux_1324 x_1345 when b_1565 ->
      (bs_aux_1041 key_1042 vec_1043 l_1044 ((l_1044 + x_1331) - 1) k_bs_aux_1324)
  br_f_bs_aux_1564 b_1565 key_1042 l_1044 u_1045 vec_1043 x_1331 k_bs_aux_1324 x_1345 when (
      not b_1565) -> (k_bs_aux_1324 (l_1044 + x_1331))
  bs_aux_1041 key_1042 vec_1043 l_1044 u_1045 k_bs_aux_1324 when (u_1045 < l_1044) -> (k_bs_aux_1324 -1)
  bs_aux_1041 key_1042 vec_1043 l_1044 u_1045 k_bs_aux_1324 when (not (u_1045 < l_1044)) ->
      (Pervasives./_1160 (u_1045 - l_1044) 2 (f_bs_aux_1555 key_1042 l_1044 u_1045 vec_1043 k_bs_aux_1324))
  bsearch_1048 key_1049 vec_1050 k_bsearch_1411 ->
      (arraysize_1163 vec_1050 (f_bsearch_1557 key_1049 vec_1050 k_bsearch_1411))
  f_1561 x_1509 -> (rand_int (f_1562 x_1509))
  f_1562 x_1509 x_1522 -> (main_1051 x_1509 x_1522 (f_1563 x_1509 x_1522))
  f_1563 x_1509 x_1522 x_1506 -> end
  f_bs_aux_1555 key_1042 l_1044 u_1045 vec_1043 k_bs_aux_1324 x_1331 ->
      (sub_1038 vec_1043 (l_1044 + x_1331) (f_bs_aux_1556 key_1042 l_1044 u_1045 vec_1043 x_1331 k_bs_aux_1324))
  f_bs_aux_1556 key_1042 l_1044 u_1045 vec_1043 x_1331 k_bs_aux_1324 x_1345 when (
      x_1345 < key_1042) -> (bs_aux_1041 key_1042 vec_1043 ((l_1044 + x_1331) + 1) u_1045 k_bs_aux_1324)
  f_bs_aux_1556 key_1042 l_1044 u_1045 vec_1043 x_1331 k_bs_aux_1324 x_1345 when (
      not (x_1345 < key_1042)) ->
      (br_f_bs_aux_1564 (x_1345 > key_1042) key_1042 l_1044 u_1045 vec_1043 x_1331 k_bs_aux_1324 x_1345)
  f_bsearch_1557 key_1049 vec_1050 k_bsearch_1411 x_1420 ->
      (bs_aux_1041 key_1049 vec_1050 0 (x_1420 - 1) k_bsearch_1411)
  f_k_main_1560 b_1503 m_1053 n_1052 x_1458 x_1471 k_main_1455 x_1488 -> (k_main_1455 ())
  f_main_1558 m_1053 n_1052 k_main_1455 x_1458 ->
      (make_array_1164 m_1053 (f_main_1559 m_1053 n_1052 x_1458 k_main_1455))
  f_main_1559 m_1053 n_1052 x_1458 k_main_1455 x_1471 when (0 <= n_1052) ->
      (k_main_1484 m_1053 n_1052 x_1458 x_1471 k_main_1455 (n_1052 = m_1053))
  f_main_1559 m_1053 n_1052 x_1458 k_main_1455 x_1471 when (not (0 <= n_1052)) ->
      (k_main_1484 m_1053 n_1052 x_1458 x_1471 k_main_1455 false)
  fail_1566 b k -> {fail} => (k ())
  fail_1567 b k -> {fail} => (k ())
  k_main_1484 m_1053 n_1052 x_1458 x_1471 k_main_1455 b_1503 when b_1503 ->
      (bsearch_1048 x_1458 x_1471 (f_k_main_1560 b_1503 m_1053 n_1052 x_1458 x_1471 k_main_1455))
  k_main_1484 m_1053 n_1052 x_1458 x_1471 k_main_1455 b_1503 when (not b_1503) -> (k_main_1455 ())
  k_sub_u_1289 i_1040 src_1039 k_sub_1283 b_1301 when b_1301 -> (k_sub_u_1300 i_1040 src_1039 k_sub_1283 ())
  k_sub_u_1289 i_1040 src_1039 k_sub_1283 b_1301 when (not b_1301) ->
      (fail_1567 true (k_sub_u_1300 i_1040 src_1039 k_sub_1283))
  k_sub_u_1300 i_1040 src_1039 k_sub_1283 x_1286 -> (k_sub_1283 0)
  k_update_1254 des_1035 i_1036 x_1037 k_update_1251 b_1266 when b_1266 -> (k_update_1251 ())
  k_update_1254 des_1035 i_1036 x_1037 k_update_1251 b_1266 when (not b_1266) -> (fail_1566 true k_update_1251)
  main_1051 n_1052 m_1053 k_main_1455 -> (make_array_1164 n_1052 (f_main_1558 m_1053 n_1052 k_main_1455))
  make_array_1164 n_1031 k_make_array_1217 -> (k_make_array_1217 n_1031)
  sub_1038 src_1039 i_1040 k_sub_1283 when (0 <= i_1040) ->
      (k_sub_u_1289 i_1040 src_1039 k_sub_1283 (i_1040 < src_1039))
  sub_1038 src_1039 i_1040 k_sub_1283 when (not (0 <= i_1040)) -> (k_sub_u_1289 i_1040 src_1039 k_sub_1283 false)
  update_1034 des_1035 i_1036 x_1037 k_update_1251 when (0 <= i_1036) ->
      (k_update_1254 des_1035 i_1036 x_1037 k_update_1251 (i_1036 < des_1035))
  update_1034 des_1035 i_1036 x_1037 k_update_1251 when (not (0 <= i_1036)) ->
      (k_update_1254 des_1035 i_1036 x_1037 k_update_1251 false)
Types:
  main_1554 : X
  bs_aux_1041 : (int -> int -> int -> int -> (int -> X) -> X)
  fail_1566 : (x_1:bool[x_1] -> (unit -> X) -> X)
  fail_1567 : (x_1:bool[x_1] -> (unit -> X) -> X)
  
(0-1) Abstracting ... DONE!

(0-2) Checking HORS ... DONE!

Error trace::
  main_1554 ... --> 
  f_1561 ... --> 
  f_1562 ... --> 
  main_1051 ... --> 
  make_array_1164 ... --> 
  f_main_1558 ... --> 
  make_array_1164 ... --> 
  f_main_1559 [1/2] ... --> 
  k_main_1484 [1/2] ... --> 
  bsearch_1048 ... --> 
  arraysize_1163 ... --> 
  f_bsearch_1557 ... --> 
  bs_aux_1041 [2/2] ... --> 
  Pervasives./_1160 ... --> 
  f_bs_aux_1555 ... --> 
  sub_1038 [2/2] ... --> 
  k_sub_u_1289 [2/2] ... --> 
  fail_1567 ... --> fail -->
  ERROR!

Spurious counter-example::
  0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 0; 1; 1; 0

(0-3) Checking counter-example ... begin Cvc3Interface.solve(366)[1]
  CVC3 input: PUSH;cnt60_v_sep_r_1880:INT; cnt60_v_sep_r_1879:INT; cnt60_v_sep_r_1878:INT;CHECKSAT (TRUE AND ((NOT FALSE) AND ((NOT (0 <= (0 + cnt60_v_sep_r_1880))) AND (TRUE AND (TRUE AND ((NOT ((cnt60_v_sep_r_1879 - 1) < 0)) AND (TRUE AND (TRUE AND (TRUE AND ((cnt60_v_sep_r_1878 = cnt60_v_sep_r_1879) AND ((0 <= cnt60_v_sep_r_1878) AND (TRUE AND (TRUE AND (TRUE AND (TRUE AND (TRUE AND (TRUE AND TRUE)))))))))))))))));COUNTERMODEL;POP;
  CVC3 output: CVC> Satisfiable.
  CVC3 output: Current scope level is 9.
  CVC3 output: %Satisfiable  Variable Assignment: % 
  CVC3 output: ASSERT (cnt60_v_sep_r_1880 = -1);
  CVC3 output: ASSERT (cnt60_v_sep_r_1879 = 1);
  CVC3 output: ASSERT (cnt60_v_sep_r_1878 = 1);
  CVC3 output: CVC> 
  v_sep_r_1880 = -1
  v_sep_r_1879 = 1
  v_sep_r_1878 = 1
  end Cvc3Interface.solve(366)[1] (0.007999 sec.)
DONE!

Unsafe!

Input for main:
  1; 1
Error trace:
  main 1 1 ->
    make_array 1 ->
    make_array 1 ->
    if true then ... ->
    bsearch 1 1 ->
      arraysize 1 ->
      bs_aux 1 1 0 0 ->
        if false then ... ->Unsupported: error trace with external funcitons
