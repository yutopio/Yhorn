\chapter{Related work}
\label{chap:related}

Interpolating theorem proving have played an important role in program
verification.  For instance, it is applied to invariant generation for
verification condition based program analysis, and predicate discovery
for the model checking by CEGAR with predicate abstraction.  The
former method is adopted when analyzing input programs by denotational
semantics such as Hoare logic, and synthesizing invariants from
strongest postconditions and weakest preconditions at various program
locations.  The latter one is used when model check a system with
infinite states by abstracting its data domain with predicates into a
finite system.

Interpolation in invariant generation is first proposed
by \cite{conf/cav/McMillan03} for unbounded model checking of a state
transition system, which does not specify the number of transition
steps to verify in iterative state exploration.  Instead of
constructing a Boolean Decision Diagram (BDD), this method adopted
Craig interpolation for compute the image fixedpoint for inductive
invariant generation.

Inspired from this method, \cite{conf/popl/HenzingerJMM04} adopted the
use of Craig interpolation for predicate discovery in CEGAR framework
with predicate abstraction, and proposed a method to derivate an
interpolant from counterexample's refutation proof derivation tree.
This work implemented the proposed method into the Blast software
model checker \cite{conf/popl/HenzingerJMS02,journals/sttt/BeyerHJM07}
and verified the effectiveness of interpolants for predicate
abstraction through an experiment of C program verification.

\paragraph{Development of interpolating theorem provers}
An interpolating prover \textsc{FOCI} \cite{website/foci} was
developed under the comprehensive wrok on quantifier-free interpolant
generation over the theory of linear arithmetic and uninterpreted
function symbols (LI+UIF) theory \cite{journals/tcs/McMillan05}.  At the same
time, various applications of interpolants for model checking was
proposed \cite{conf/tacas/McMillan05}. They incorporated the algorithm
into Z3 SMT solver \cite{conf/tacas/MouraB08} and it is possible to
generate an interpolant from proofs generated by
Z3 \cite{conf/fmcad/McMillan11}.


On the other hand, an interpolating method without using proof
derivation was proposed that made use of the specific characteristics
of linear arithmetics.  \textsc{CLP-Prover} \cite{website/clp} is
another interpolating theorem prover with the theoretical ground of
linear constraint generation.  It focuses on interpolation over LI+UIF
and adopts Farkas's Lemma \cite{journals/networks/Rajan90} for give a
reasoning for handling linear
inequalities \cite{conf/vmcai/RybalchenkoS07, conf/cav/Rybalchenko10}.
Because the \textsc{CLP-Prover} cannot handle logical formulas with
disjunctions, we extended the basic principle of this work to handle
disjunctions. Our interpolating algorithm was strongly inspired.

Note that the suggested interpolating algorithms so far were not
complete in the sense that the algorithms may not be able to find a
suitable predicate that is necessary for a model checker to terminate.
Although it may be possible to simply enumerate interpolants in a
complete manner, its cost is not negligible with respect to the
computation time because of combinatorial explosion.
\cite{conf/tacas/JhalaM06} suggested a practical way to
obtain complete interpolating algorithm.

\paragraph{Extension to Horn clause solvers}
As a model checking technique, various methods are proposed to
efficiently eliminate spurious counterexamples from an abstract system
and terminate CEGAR process with less number of cycles.  Main
principles are support of disjunctive problems and extension to Horn
clause solvers.

One of them is work done by \cite{conf/pldi/BeyerHMR07} to eliminate
spurious paths that pass over loops.  The method converts a
counterexample from the model checker into a path that is a subgraph
of program's control flow graph, and performs a invariant synthesis
over it.  Here, the control flow graph may contain loops, it is not
suffcieint by the convential interpolation, and rather it required a
disjunctive reasoning.

As we explained in Chapter~\ref{chap:interpolation}, when
interpolating between two logical formulas, it is necessary to combine
interpolants by conjunctions and disjunctions.  To minimize the number
of terms efficiently, \cite{conf/cav/AlbarghouthiM13} suggested a
non-deterministic method of building such interpolant by wisely
sampling a half-interpolant.

For solving a complex system, it may not be possible to analyze
system's behavior by interpolation.  \cite{conf/aplas/GuptaPR11}
showed an algorithm to solve Horn clauses over LI+UIF.

One of the most important applications of Horn clause solving is
verifying higher-order functional programs.  Interpolation is used as
a sub procedure of solving Horn clauses for dependent type
inference \cite{conf/ppdp/UnnoK09, conf/pepm/SatoUK13} in this
context. In MoCHi, the refinement types are given for values and
variables for program abstraction.  Horn clause solving is necessary
for inferring the refinment types.  \cite{conf/popl/Terauchi10}
suggested a method for dependent type inference algorithm as
well. Their algorithm is complete in the sense that it eventually
returns a solution which terminates the verification process.

Another application of Horn clause solving is the verification of
concurrent systems \cite{conf/popl/GuptaPR11}. The work suggested to
describe a multi-thread program's behavior in Horn clauses and perform
model checking over abstract system.

Finally, some research integrated disjunctive interpolating methods
with Horn clause solving algorithms.  In previously suggested methods
in \cite{conf/popl/HenzingerJMM04, conf/cav/McMillan06}, it was not
possible to consider multiple spurious
paths.  \cite{conf/cav/RummerHK13} suggested an algorithm to solve
disjunctive Horn clauses, and it became possible to give a stronger
reasoning on a program invariant where multiple paths meet.  It also
enabled the abstraction for the case that branch conditions had a
disjunctive operator in them.

\paragraph{Recent work}

One of the recent extensions of Horn clause solving is to handle
non-linear constraints \cite{conf/cav/DaiXZ13}.  For instance, if a
program contains integer multiplication operation over variables,
existing algorithms cannot infer program invariants.  This research
aims to overcome the hurdle and infer non-linear invariants for
program verification.

As another direction of extension, some works are done for solving
Horn clauses with qunatified consequences \cite{conf/sas/BjornerMR13,
conf/cav/BeyenePR13}.  They are used to abstract more complex systems
efficiently.
