\chapter{Conclusion}
\label{chap:conclusion}

In this thesis, we have suggested a new algorithm to discover
predicates that are suitable for program verification.  We put a
hypothesis that the program invariants are prone to be expressed in
simple expressions.  Based on this hypothesis, our algorithm tries to
obtain a small predicate with a fewer number of terms.

To accomplish this goal on Craig interpolation over linear
arithmetics, we first explained a method to reduce interpolation into
linear constraint generation by using Farkas's Lemma.  This method
preserves a set of solutions during the computation process so to make
it possible to choose a small solution later. This enabled a Horn
clause solver to build small solutions when it uses the method as a
subroutine due to the ability to choose a common predicate among
different interpolating problems. Additionally, we mentioned the
possibility of choosing small solutions in interpolating general
formulas by wisely choose the order to combine set of solutions during
the computation. In the end we extended the method to solve symmetric
interpolation problems to perform predicate discovery at multiple
locations in the program at the same time.

Next we extended our interpolating method to solve recursion-less
disjunctive Horn clauses.  Same as previous, this method also
describes a set of predicates for each predicate variable in linear
constraints.  The algorithm builds a solution in constructive manner
and is thus scalable for the size of input problems. If the algorithm
fails to find a simple solution, it tries to find a larger solution in
error-guided manner.  By observing an unsatisfiable core, the
algorithm enlarges a size of solution for certain predicates.  We have
also proposed to simplify linear constraints by quantifier elimination
for preventing exponential growth of them.

We have incorporated our algorithm into MoCHi and confirmed the
effectiveness to a certain level.

We would like to extend the algorithm further to achieve better
performance in constraint generation.  It is also desired to support
uninterpreted function symbols in our theory.
