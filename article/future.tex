\chapter{Future Work}
\label{chap:future}

Our proposed algorithms have still numbers of rooms for further
improvement.  Based on the experiment result from the previous
chapter, here we give raise some analaysis and discussion for them.

\paragraph{Space explosion for constraint duplication}
Our experimental implementation did not simplify the linear constraint
for every predicate variable and it caused a linear constraint
unsolvable due to the shortage of space resources by exponential
growth of constraints.  As we described in the algorithm explanation,
it may be possible to perform quantifier elimination for reduce the
size of linear constraints.  On the other hand without the
optimization, the constraint duplication may occur every time a
constraint is generated for the predicate vertices with multiple
successors.

We think that the algorithm with such optimization would not cause a
memory shortage because constraints gently grow according to roughly
the number of vertices.  Although the worst case can be produced by
causing a conjunction split frequently, we consider that it is not the
common case in program verification because of our hypothesis.

In practice, the size of constraint may be limited by simplification,
and additionally, normally the algorithm does not need to preserve the
constraint until the time to build a concrete solution in the end.


\paragraph{Quantifier elimination}
It may be useful to prepare a customized algorithm for performing
quantifier elimination for linear expressions because linear
constraints that are generated from our algorithm have certain pattern
in their format.

In the preliminary expriment before incorporating into MoCHi, although
we have tried the quantifier elimination over integer theory, the
result was unsatisfactory in the sense that simplified formulas had
disjunctions.  It caused the loss of efficiency in solving constraints
and generating unsatisfiable cores.

We have also tried the quantifier elimination over real space, and the
result was better than the integer version.  However, because our algorithm
first treats all linear inequalities over integer space, more study on
the gap betweem these two are required when we consider the completeness.

\paragraph{Solving linear constraints}

Although we solve the constraints by a general SMT solver Z3, GNU
Linear Programming Kit (GLPK) may be sufficient for solving
constraints.  The linear programming solver should support sparse
matrix because our algorithm generates constraints that are sparse.


\paragraph{Generation and choice of unsatisfiable core}
Our Horn clause solver make use of Z3 to obtain an unsatisfiable core
from the linear constraints.  However the extraction of unsatisfiable
core from the proof may cost certain level of computation.
Originally, it is better that the theorem prover customizes to extract



\paragraph{Applications for other work}
In our research, we put a special focus on solving Horn clauses for
dependent type inference in higher-order program verification.
However, solving Horn clauses are becoming common to describe various
kinds of programs' behavior. For instance in verifying multi-threaded
programs, Horn clauses can describe the conditions of data exchange
between threads, and confirm the validity of semaphores for mutural
exclusion.  We expect our algorithm achieve better performance in
other work when customized into different contexts.

By puting such effort for further improvement on our algorithm, we can
conclude that the algorithm may be able to achive better performance
in Horn clause solving, and become a necessary tool for program verification.
