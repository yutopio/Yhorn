%{
module Parser

open Error
open Types

let combineFormulae opAnd x y =
    match (opAnd, x, y) with
    | (true, And x, And y) -> And(x @ y)
    | (true, And x, _) -> And(x @ [ y ])
    | (true, _, And y) -> And(x :: y)
    | (true, _, _) -> And [ x ; y ]
    | (_, Or x, Or y) -> Or(x @ y)
    | (_, Or x, _) -> Or(x @ [ y ])
    | (_, _, Or y) -> Or(x :: y)
    | _ -> Or [ x ; y ]
%}

%token <string> IDENT
%token <float> FLOAT
%token <int> OP
%token PLUS MINUS
%token AND OR
%token LPAREN RPAREN
%token SEMICOLON
%token EOF

%start inputUnit
%type <formula * formula> inputUnit

%%

inputUnit:
    | formulae SEMICOLON formulae EOF { ($1, $3) }
;

formulae:
    | formula                   { Expr($1) }
    | LPAREN formulae RPAREN    { $2 }
    | formulae AND formulae     { combineFormulae true $1 $3 }
    | formulae OR formulae      { combineFormulae false $1 $3 }
;

formula:
    | expr OP expr  { ($2, $1, $3) }
;

expr:
    | term              { [$1] }
    | expr PLUS term    { $1 @ [$3] }
    | expr MINUS term   { let (a, b) = $3 in $1 @ [ (-a, b) ] }
;

term:
    | num       { ($1, None) }
    | num IDENT { ($1, Some $2) }
    | IDENT     { (1., Some $1) }
;

num:
    | FLOAT         { $1 }
    | PLUS FLOAT    { $2 }
    | MINUS FLOAT   { -($2) }
;
